// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'app_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AuthFailures {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NetworkFailure value) networkFailure,
    required TResult Function(_IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(_EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(_CanceledByUser value) canecledByUser,
    required TResult Function(_AuthServerError value) serverError,
    required TResult Function(_WrongEmail value) wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFailuresCopyWith<$Res> {
  factory $AuthFailuresCopyWith(
          AuthFailures value, $Res Function(AuthFailures) then) =
      _$AuthFailuresCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthFailuresCopyWithImpl<$Res> implements $AuthFailuresCopyWith<$Res> {
  _$AuthFailuresCopyWithImpl(this._value, this._then);

  final AuthFailures _value;
  // ignore: unused_field
  final $Res Function(AuthFailures) _then;
}

/// @nodoc
abstract class _$$_NetworkFailureCopyWith<$Res> {
  factory _$$_NetworkFailureCopyWith(
          _$_NetworkFailure value, $Res Function(_$_NetworkFailure) then) =
      __$$_NetworkFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NetworkFailureCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$_NetworkFailureCopyWith<$Res> {
  __$$_NetworkFailureCopyWithImpl(
      _$_NetworkFailure _value, $Res Function(_$_NetworkFailure) _then)
      : super(_value, (v) => _then(v as _$_NetworkFailure));

  @override
  _$_NetworkFailure get _value => super._value as _$_NetworkFailure;
}

/// @nodoc

class _$_NetworkFailure implements _NetworkFailure {
  const _$_NetworkFailure();

  @override
  String toString() {
    return 'AuthFailures.networkFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_NetworkFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return networkFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return networkFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (networkFailure != null) {
      return networkFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NetworkFailure value) networkFailure,
    required TResult Function(_IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(_EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(_CanceledByUser value) canecledByUser,
    required TResult Function(_AuthServerError value) serverError,
    required TResult Function(_WrongEmail value) wrongEmail,
  }) {
    return networkFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
  }) {
    return networkFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (networkFailure != null) {
      return networkFailure(this);
    }
    return orElse();
  }
}

abstract class _NetworkFailure implements AuthFailures {
  const factory _NetworkFailure() = _$_NetworkFailure;
}

/// @nodoc
abstract class _$$_IncorrectEmailOrPasswordCopyWith<$Res> {
  factory _$$_IncorrectEmailOrPasswordCopyWith(
          _$_IncorrectEmailOrPassword value,
          $Res Function(_$_IncorrectEmailOrPassword) then) =
      __$$_IncorrectEmailOrPasswordCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_IncorrectEmailOrPasswordCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$_IncorrectEmailOrPasswordCopyWith<$Res> {
  __$$_IncorrectEmailOrPasswordCopyWithImpl(_$_IncorrectEmailOrPassword _value,
      $Res Function(_$_IncorrectEmailOrPassword) _then)
      : super(_value, (v) => _then(v as _$_IncorrectEmailOrPassword));

  @override
  _$_IncorrectEmailOrPassword get _value =>
      super._value as _$_IncorrectEmailOrPassword;
}

/// @nodoc

class _$_IncorrectEmailOrPassword implements _IncorrectEmailOrPassword {
  const _$_IncorrectEmailOrPassword();

  @override
  String toString() {
    return 'AuthFailures.incorrectEmailOrPassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IncorrectEmailOrPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return incorrectEmailOrPassword();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return incorrectEmailOrPassword?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (incorrectEmailOrPassword != null) {
      return incorrectEmailOrPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NetworkFailure value) networkFailure,
    required TResult Function(_IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(_EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(_CanceledByUser value) canecledByUser,
    required TResult Function(_AuthServerError value) serverError,
    required TResult Function(_WrongEmail value) wrongEmail,
  }) {
    return incorrectEmailOrPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
  }) {
    return incorrectEmailOrPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (incorrectEmailOrPassword != null) {
      return incorrectEmailOrPassword(this);
    }
    return orElse();
  }
}

abstract class _IncorrectEmailOrPassword implements AuthFailures {
  const factory _IncorrectEmailOrPassword() = _$_IncorrectEmailOrPassword;
}

/// @nodoc
abstract class _$$_EmailAlreadyRegisteredCopyWith<$Res> {
  factory _$$_EmailAlreadyRegisteredCopyWith(_$_EmailAlreadyRegistered value,
          $Res Function(_$_EmailAlreadyRegistered) then) =
      __$$_EmailAlreadyRegisteredCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_EmailAlreadyRegisteredCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$_EmailAlreadyRegisteredCopyWith<$Res> {
  __$$_EmailAlreadyRegisteredCopyWithImpl(_$_EmailAlreadyRegistered _value,
      $Res Function(_$_EmailAlreadyRegistered) _then)
      : super(_value, (v) => _then(v as _$_EmailAlreadyRegistered));

  @override
  _$_EmailAlreadyRegistered get _value =>
      super._value as _$_EmailAlreadyRegistered;
}

/// @nodoc

class _$_EmailAlreadyRegistered implements _EmailAlreadyRegistered {
  const _$_EmailAlreadyRegistered();

  @override
  String toString() {
    return 'AuthFailures.emailAlreadyRegistered()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EmailAlreadyRegistered);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return emailAlreadyRegistered();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return emailAlreadyRegistered?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (emailAlreadyRegistered != null) {
      return emailAlreadyRegistered();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NetworkFailure value) networkFailure,
    required TResult Function(_IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(_EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(_CanceledByUser value) canecledByUser,
    required TResult Function(_AuthServerError value) serverError,
    required TResult Function(_WrongEmail value) wrongEmail,
  }) {
    return emailAlreadyRegistered(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
  }) {
    return emailAlreadyRegistered?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (emailAlreadyRegistered != null) {
      return emailAlreadyRegistered(this);
    }
    return orElse();
  }
}

abstract class _EmailAlreadyRegistered implements AuthFailures {
  const factory _EmailAlreadyRegistered() = _$_EmailAlreadyRegistered;
}

/// @nodoc
abstract class _$$_CanceledByUserCopyWith<$Res> {
  factory _$$_CanceledByUserCopyWith(
          _$_CanceledByUser value, $Res Function(_$_CanceledByUser) then) =
      __$$_CanceledByUserCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CanceledByUserCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$_CanceledByUserCopyWith<$Res> {
  __$$_CanceledByUserCopyWithImpl(
      _$_CanceledByUser _value, $Res Function(_$_CanceledByUser) _then)
      : super(_value, (v) => _then(v as _$_CanceledByUser));

  @override
  _$_CanceledByUser get _value => super._value as _$_CanceledByUser;
}

/// @nodoc

class _$_CanceledByUser implements _CanceledByUser {
  const _$_CanceledByUser();

  @override
  String toString() {
    return 'AuthFailures.canecledByUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_CanceledByUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return canecledByUser();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return canecledByUser?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (canecledByUser != null) {
      return canecledByUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NetworkFailure value) networkFailure,
    required TResult Function(_IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(_EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(_CanceledByUser value) canecledByUser,
    required TResult Function(_AuthServerError value) serverError,
    required TResult Function(_WrongEmail value) wrongEmail,
  }) {
    return canecledByUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
  }) {
    return canecledByUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (canecledByUser != null) {
      return canecledByUser(this);
    }
    return orElse();
  }
}

abstract class _CanceledByUser implements AuthFailures {
  const factory _CanceledByUser() = _$_CanceledByUser;
}

/// @nodoc
abstract class _$$_AuthServerErrorCopyWith<$Res> {
  factory _$$_AuthServerErrorCopyWith(
          _$_AuthServerError value, $Res Function(_$_AuthServerError) then) =
      __$$_AuthServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AuthServerErrorCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$_AuthServerErrorCopyWith<$Res> {
  __$$_AuthServerErrorCopyWithImpl(
      _$_AuthServerError _value, $Res Function(_$_AuthServerError) _then)
      : super(_value, (v) => _then(v as _$_AuthServerError));

  @override
  _$_AuthServerError get _value => super._value as _$_AuthServerError;
}

/// @nodoc

class _$_AuthServerError implements _AuthServerError {
  const _$_AuthServerError();

  @override
  String toString() {
    return 'AuthFailures.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AuthServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NetworkFailure value) networkFailure,
    required TResult Function(_IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(_EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(_CanceledByUser value) canecledByUser,
    required TResult Function(_AuthServerError value) serverError,
    required TResult Function(_WrongEmail value) wrongEmail,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class _AuthServerError implements AuthFailures {
  const factory _AuthServerError() = _$_AuthServerError;
}

/// @nodoc
abstract class _$$_WrongEmailCopyWith<$Res> {
  factory _$$_WrongEmailCopyWith(
          _$_WrongEmail value, $Res Function(_$_WrongEmail) then) =
      __$$_WrongEmailCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_WrongEmailCopyWithImpl<$Res> extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$_WrongEmailCopyWith<$Res> {
  __$$_WrongEmailCopyWithImpl(
      _$_WrongEmail _value, $Res Function(_$_WrongEmail) _then)
      : super(_value, (v) => _then(v as _$_WrongEmail));

  @override
  _$_WrongEmail get _value => super._value as _$_WrongEmail;
}

/// @nodoc

class _$_WrongEmail implements _WrongEmail {
  const _$_WrongEmail();

  @override
  String toString() {
    return 'AuthFailures.wrongEmail()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_WrongEmail);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return wrongEmail();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return wrongEmail?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongEmail != null) {
      return wrongEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NetworkFailure value) networkFailure,
    required TResult Function(_IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(_EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(_CanceledByUser value) canecledByUser,
    required TResult Function(_AuthServerError value) serverError,
    required TResult Function(_WrongEmail value) wrongEmail,
  }) {
    return wrongEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
  }) {
    return wrongEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NetworkFailure value)? networkFailure,
    TResult Function(_IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(_EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(_CanceledByUser value)? canecledByUser,
    TResult Function(_AuthServerError value)? serverError,
    TResult Function(_WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongEmail != null) {
      return wrongEmail(this);
    }
    return orElse();
  }
}

abstract class _WrongEmail implements AuthFailures {
  const factory _WrongEmail() = _$_WrongEmail;
}

/// @nodoc
mixin _$CashFailures {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noDataStored,
    required TResult Function() getDataFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoDataStored value) noDataStored,
    required TResult Function(_GetDataFailure value) getDataFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NoDataStored value)? noDataStored,
    TResult Function(_GetDataFailure value)? getDataFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoDataStored value)? noDataStored,
    TResult Function(_GetDataFailure value)? getDataFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CashFailuresCopyWith<$Res> {
  factory $CashFailuresCopyWith(
          CashFailures value, $Res Function(CashFailures) then) =
      _$CashFailuresCopyWithImpl<$Res>;
}

/// @nodoc
class _$CashFailuresCopyWithImpl<$Res> implements $CashFailuresCopyWith<$Res> {
  _$CashFailuresCopyWithImpl(this._value, this._then);

  final CashFailures _value;
  // ignore: unused_field
  final $Res Function(CashFailures) _then;
}

/// @nodoc
abstract class _$$_NoDataStoredCopyWith<$Res> {
  factory _$$_NoDataStoredCopyWith(
          _$_NoDataStored value, $Res Function(_$_NoDataStored) then) =
      __$$_NoDataStoredCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NoDataStoredCopyWithImpl<$Res>
    extends _$CashFailuresCopyWithImpl<$Res>
    implements _$$_NoDataStoredCopyWith<$Res> {
  __$$_NoDataStoredCopyWithImpl(
      _$_NoDataStored _value, $Res Function(_$_NoDataStored) _then)
      : super(_value, (v) => _then(v as _$_NoDataStored));

  @override
  _$_NoDataStored get _value => super._value as _$_NoDataStored;
}

/// @nodoc

class _$_NoDataStored implements _NoDataStored {
  const _$_NoDataStored();

  @override
  String toString() {
    return 'CashFailures.noDataStored()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_NoDataStored);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noDataStored,
    required TResult Function() getDataFailure,
  }) {
    return noDataStored();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
  }) {
    return noDataStored?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
    required TResult orElse(),
  }) {
    if (noDataStored != null) {
      return noDataStored();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoDataStored value) noDataStored,
    required TResult Function(_GetDataFailure value) getDataFailure,
  }) {
    return noDataStored(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NoDataStored value)? noDataStored,
    TResult Function(_GetDataFailure value)? getDataFailure,
  }) {
    return noDataStored?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoDataStored value)? noDataStored,
    TResult Function(_GetDataFailure value)? getDataFailure,
    required TResult orElse(),
  }) {
    if (noDataStored != null) {
      return noDataStored(this);
    }
    return orElse();
  }
}

abstract class _NoDataStored implements CashFailures {
  const factory _NoDataStored() = _$_NoDataStored;
}

/// @nodoc
abstract class _$$_GetDataFailureCopyWith<$Res> {
  factory _$$_GetDataFailureCopyWith(
          _$_GetDataFailure value, $Res Function(_$_GetDataFailure) then) =
      __$$_GetDataFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GetDataFailureCopyWithImpl<$Res>
    extends _$CashFailuresCopyWithImpl<$Res>
    implements _$$_GetDataFailureCopyWith<$Res> {
  __$$_GetDataFailureCopyWithImpl(
      _$_GetDataFailure _value, $Res Function(_$_GetDataFailure) _then)
      : super(_value, (v) => _then(v as _$_GetDataFailure));

  @override
  _$_GetDataFailure get _value => super._value as _$_GetDataFailure;
}

/// @nodoc

class _$_GetDataFailure implements _GetDataFailure {
  const _$_GetDataFailure();

  @override
  String toString() {
    return 'CashFailures.getDataFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GetDataFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noDataStored,
    required TResult Function() getDataFailure,
  }) {
    return getDataFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
  }) {
    return getDataFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
    required TResult orElse(),
  }) {
    if (getDataFailure != null) {
      return getDataFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NoDataStored value) noDataStored,
    required TResult Function(_GetDataFailure value) getDataFailure,
  }) {
    return getDataFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NoDataStored value)? noDataStored,
    TResult Function(_GetDataFailure value)? getDataFailure,
  }) {
    return getDataFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NoDataStored value)? noDataStored,
    TResult Function(_GetDataFailure value)? getDataFailure,
    required TResult orElse(),
  }) {
    if (getDataFailure != null) {
      return getDataFailure(this);
    }
    return orElse();
  }
}

abstract class _GetDataFailure implements CashFailures {
  const factory _GetDataFailure() = _$_GetDataFailure;
}

/// @nodoc
mixin _$CurrentUserFailures {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() unverifiedEmail,
    required TResult Function() cashError,
    required TResult Function() serverError,
    required TResult Function() uncompletedAccount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NocurrentUser value) noCurrentUser,
    required TResult Function(_UnverifiedEmail value) unverifiedEmail,
    required TResult Function(_CashError value) cashError,
    required TResult Function(_CurrentUserServerError value) serverError,
    required TResult Function(_UncompletedAccount value) uncompletedAccount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CurrentUserFailuresCopyWith<$Res> {
  factory $CurrentUserFailuresCopyWith(
          CurrentUserFailures value, $Res Function(CurrentUserFailures) then) =
      _$CurrentUserFailuresCopyWithImpl<$Res>;
}

/// @nodoc
class _$CurrentUserFailuresCopyWithImpl<$Res>
    implements $CurrentUserFailuresCopyWith<$Res> {
  _$CurrentUserFailuresCopyWithImpl(this._value, this._then);

  final CurrentUserFailures _value;
  // ignore: unused_field
  final $Res Function(CurrentUserFailures) _then;
}

/// @nodoc
abstract class _$$_NocurrentUserCopyWith<$Res> {
  factory _$$_NocurrentUserCopyWith(
          _$_NocurrentUser value, $Res Function(_$_NocurrentUser) then) =
      __$$_NocurrentUserCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NocurrentUserCopyWithImpl<$Res>
    extends _$CurrentUserFailuresCopyWithImpl<$Res>
    implements _$$_NocurrentUserCopyWith<$Res> {
  __$$_NocurrentUserCopyWithImpl(
      _$_NocurrentUser _value, $Res Function(_$_NocurrentUser) _then)
      : super(_value, (v) => _then(v as _$_NocurrentUser));

  @override
  _$_NocurrentUser get _value => super._value as _$_NocurrentUser;
}

/// @nodoc

class _$_NocurrentUser implements _NocurrentUser {
  const _$_NocurrentUser();

  @override
  String toString() {
    return 'CurrentUserFailures.noCurrentUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_NocurrentUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() unverifiedEmail,
    required TResult Function() cashError,
    required TResult Function() serverError,
    required TResult Function() uncompletedAccount,
  }) {
    return noCurrentUser();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
  }) {
    return noCurrentUser?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (noCurrentUser != null) {
      return noCurrentUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NocurrentUser value) noCurrentUser,
    required TResult Function(_UnverifiedEmail value) unverifiedEmail,
    required TResult Function(_CashError value) cashError,
    required TResult Function(_CurrentUserServerError value) serverError,
    required TResult Function(_UncompletedAccount value) uncompletedAccount,
  }) {
    return noCurrentUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
  }) {
    return noCurrentUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (noCurrentUser != null) {
      return noCurrentUser(this);
    }
    return orElse();
  }
}

abstract class _NocurrentUser implements CurrentUserFailures {
  const factory _NocurrentUser() = _$_NocurrentUser;
}

/// @nodoc
abstract class _$$_UnverifiedEmailCopyWith<$Res> {
  factory _$$_UnverifiedEmailCopyWith(
          _$_UnverifiedEmail value, $Res Function(_$_UnverifiedEmail) then) =
      __$$_UnverifiedEmailCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnverifiedEmailCopyWithImpl<$Res>
    extends _$CurrentUserFailuresCopyWithImpl<$Res>
    implements _$$_UnverifiedEmailCopyWith<$Res> {
  __$$_UnverifiedEmailCopyWithImpl(
      _$_UnverifiedEmail _value, $Res Function(_$_UnverifiedEmail) _then)
      : super(_value, (v) => _then(v as _$_UnverifiedEmail));

  @override
  _$_UnverifiedEmail get _value => super._value as _$_UnverifiedEmail;
}

/// @nodoc

class _$_UnverifiedEmail implements _UnverifiedEmail {
  const _$_UnverifiedEmail();

  @override
  String toString() {
    return 'CurrentUserFailures.unverifiedEmail()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_UnverifiedEmail);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() unverifiedEmail,
    required TResult Function() cashError,
    required TResult Function() serverError,
    required TResult Function() uncompletedAccount,
  }) {
    return unverifiedEmail();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
  }) {
    return unverifiedEmail?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (unverifiedEmail != null) {
      return unverifiedEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NocurrentUser value) noCurrentUser,
    required TResult Function(_UnverifiedEmail value) unverifiedEmail,
    required TResult Function(_CashError value) cashError,
    required TResult Function(_CurrentUserServerError value) serverError,
    required TResult Function(_UncompletedAccount value) uncompletedAccount,
  }) {
    return unverifiedEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
  }) {
    return unverifiedEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (unverifiedEmail != null) {
      return unverifiedEmail(this);
    }
    return orElse();
  }
}

abstract class _UnverifiedEmail implements CurrentUserFailures {
  const factory _UnverifiedEmail() = _$_UnverifiedEmail;
}

/// @nodoc
abstract class _$$_CashErrorCopyWith<$Res> {
  factory _$$_CashErrorCopyWith(
          _$_CashError value, $Res Function(_$_CashError) then) =
      __$$_CashErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CashErrorCopyWithImpl<$Res>
    extends _$CurrentUserFailuresCopyWithImpl<$Res>
    implements _$$_CashErrorCopyWith<$Res> {
  __$$_CashErrorCopyWithImpl(
      _$_CashError _value, $Res Function(_$_CashError) _then)
      : super(_value, (v) => _then(v as _$_CashError));

  @override
  _$_CashError get _value => super._value as _$_CashError;
}

/// @nodoc

class _$_CashError implements _CashError {
  const _$_CashError();

  @override
  String toString() {
    return 'CurrentUserFailures.cashError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_CashError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() unverifiedEmail,
    required TResult Function() cashError,
    required TResult Function() serverError,
    required TResult Function() uncompletedAccount,
  }) {
    return cashError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
  }) {
    return cashError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (cashError != null) {
      return cashError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NocurrentUser value) noCurrentUser,
    required TResult Function(_UnverifiedEmail value) unverifiedEmail,
    required TResult Function(_CashError value) cashError,
    required TResult Function(_CurrentUserServerError value) serverError,
    required TResult Function(_UncompletedAccount value) uncompletedAccount,
  }) {
    return cashError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
  }) {
    return cashError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (cashError != null) {
      return cashError(this);
    }
    return orElse();
  }
}

abstract class _CashError implements CurrentUserFailures {
  const factory _CashError() = _$_CashError;
}

/// @nodoc
abstract class _$$_CurrentUserServerErrorCopyWith<$Res> {
  factory _$$_CurrentUserServerErrorCopyWith(_$_CurrentUserServerError value,
          $Res Function(_$_CurrentUserServerError) then) =
      __$$_CurrentUserServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CurrentUserServerErrorCopyWithImpl<$Res>
    extends _$CurrentUserFailuresCopyWithImpl<$Res>
    implements _$$_CurrentUserServerErrorCopyWith<$Res> {
  __$$_CurrentUserServerErrorCopyWithImpl(_$_CurrentUserServerError _value,
      $Res Function(_$_CurrentUserServerError) _then)
      : super(_value, (v) => _then(v as _$_CurrentUserServerError));

  @override
  _$_CurrentUserServerError get _value =>
      super._value as _$_CurrentUserServerError;
}

/// @nodoc

class _$_CurrentUserServerError implements _CurrentUserServerError {
  const _$_CurrentUserServerError();

  @override
  String toString() {
    return 'CurrentUserFailures.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CurrentUserServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() unverifiedEmail,
    required TResult Function() cashError,
    required TResult Function() serverError,
    required TResult Function() uncompletedAccount,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NocurrentUser value) noCurrentUser,
    required TResult Function(_UnverifiedEmail value) unverifiedEmail,
    required TResult Function(_CashError value) cashError,
    required TResult Function(_CurrentUserServerError value) serverError,
    required TResult Function(_UncompletedAccount value) uncompletedAccount,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class _CurrentUserServerError implements CurrentUserFailures {
  const factory _CurrentUserServerError() = _$_CurrentUserServerError;
}

/// @nodoc
abstract class _$$_UncompletedAccountCopyWith<$Res> {
  factory _$$_UncompletedAccountCopyWith(_$_UncompletedAccount value,
          $Res Function(_$_UncompletedAccount) then) =
      __$$_UncompletedAccountCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UncompletedAccountCopyWithImpl<$Res>
    extends _$CurrentUserFailuresCopyWithImpl<$Res>
    implements _$$_UncompletedAccountCopyWith<$Res> {
  __$$_UncompletedAccountCopyWithImpl(
      _$_UncompletedAccount _value, $Res Function(_$_UncompletedAccount) _then)
      : super(_value, (v) => _then(v as _$_UncompletedAccount));

  @override
  _$_UncompletedAccount get _value => super._value as _$_UncompletedAccount;
}

/// @nodoc

class _$_UncompletedAccount implements _UncompletedAccount {
  const _$_UncompletedAccount();

  @override
  String toString() {
    return 'CurrentUserFailures.uncompletedAccount()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_UncompletedAccount);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() unverifiedEmail,
    required TResult Function() cashError,
    required TResult Function() serverError,
    required TResult Function() uncompletedAccount,
  }) {
    return uncompletedAccount();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
  }) {
    return uncompletedAccount?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? unverifiedEmail,
    TResult Function()? cashError,
    TResult Function()? serverError,
    TResult Function()? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (uncompletedAccount != null) {
      return uncompletedAccount();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_NocurrentUser value) noCurrentUser,
    required TResult Function(_UnverifiedEmail value) unverifiedEmail,
    required TResult Function(_CashError value) cashError,
    required TResult Function(_CurrentUserServerError value) serverError,
    required TResult Function(_UncompletedAccount value) uncompletedAccount,
  }) {
    return uncompletedAccount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
  }) {
    return uncompletedAccount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_NocurrentUser value)? noCurrentUser,
    TResult Function(_UnverifiedEmail value)? unverifiedEmail,
    TResult Function(_CashError value)? cashError,
    TResult Function(_CurrentUserServerError value)? serverError,
    TResult Function(_UncompletedAccount value)? uncompletedAccount,
    required TResult orElse(),
  }) {
    if (uncompletedAccount != null) {
      return uncompletedAccount(this);
    }
    return orElse();
  }
}

abstract class _UncompletedAccount implements CurrentUserFailures {
  const factory _UncompletedAccount() = _$_UncompletedAccount;
}
