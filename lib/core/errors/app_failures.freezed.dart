// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'app_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AuthFailures {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCurrentUser value) noCurrentUser,
    required TResult Function(NetworkFailure value) networkFailure,
    required TResult Function(IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(CanceledByUser value) canecledByUser,
    required TResult Function(ServerError value) serverError,
    required TResult Function(WrongEmail value) wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthFailuresCopyWith<$Res> {
  factory $AuthFailuresCopyWith(
          AuthFailures value, $Res Function(AuthFailures) then) =
      _$AuthFailuresCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthFailuresCopyWithImpl<$Res> implements $AuthFailuresCopyWith<$Res> {
  _$AuthFailuresCopyWithImpl(this._value, this._then);

  final AuthFailures _value;
  // ignore: unused_field
  final $Res Function(AuthFailures) _then;
}

/// @nodoc
abstract class _$$NoCurrentUserCopyWith<$Res> {
  factory _$$NoCurrentUserCopyWith(
          _$NoCurrentUser value, $Res Function(_$NoCurrentUser) then) =
      __$$NoCurrentUserCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoCurrentUserCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$NoCurrentUserCopyWith<$Res> {
  __$$NoCurrentUserCopyWithImpl(
      _$NoCurrentUser _value, $Res Function(_$NoCurrentUser) _then)
      : super(_value, (v) => _then(v as _$NoCurrentUser));

  @override
  _$NoCurrentUser get _value => super._value as _$NoCurrentUser;
}

/// @nodoc

class _$NoCurrentUser implements NoCurrentUser {
  const _$NoCurrentUser();

  @override
  String toString() {
    return 'AuthFailures.noCurrentUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoCurrentUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return noCurrentUser();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return noCurrentUser?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (noCurrentUser != null) {
      return noCurrentUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCurrentUser value) noCurrentUser,
    required TResult Function(NetworkFailure value) networkFailure,
    required TResult Function(IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(CanceledByUser value) canecledByUser,
    required TResult Function(ServerError value) serverError,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return noCurrentUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
  }) {
    return noCurrentUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (noCurrentUser != null) {
      return noCurrentUser(this);
    }
    return orElse();
  }
}

abstract class NoCurrentUser implements AuthFailures {
  const factory NoCurrentUser() = _$NoCurrentUser;
}

/// @nodoc
abstract class _$$NetworkFailureCopyWith<$Res> {
  factory _$$NetworkFailureCopyWith(
          _$NetworkFailure value, $Res Function(_$NetworkFailure) then) =
      __$$NetworkFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NetworkFailureCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$NetworkFailureCopyWith<$Res> {
  __$$NetworkFailureCopyWithImpl(
      _$NetworkFailure _value, $Res Function(_$NetworkFailure) _then)
      : super(_value, (v) => _then(v as _$NetworkFailure));

  @override
  _$NetworkFailure get _value => super._value as _$NetworkFailure;
}

/// @nodoc

class _$NetworkFailure implements NetworkFailure {
  const _$NetworkFailure();

  @override
  String toString() {
    return 'AuthFailures.networkFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NetworkFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return networkFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return networkFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (networkFailure != null) {
      return networkFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCurrentUser value) noCurrentUser,
    required TResult Function(NetworkFailure value) networkFailure,
    required TResult Function(IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(CanceledByUser value) canecledByUser,
    required TResult Function(ServerError value) serverError,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return networkFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
  }) {
    return networkFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (networkFailure != null) {
      return networkFailure(this);
    }
    return orElse();
  }
}

abstract class NetworkFailure implements AuthFailures {
  const factory NetworkFailure() = _$NetworkFailure;
}

/// @nodoc
abstract class _$$IncorrectEmailOrPasswordCopyWith<$Res> {
  factory _$$IncorrectEmailOrPasswordCopyWith(_$IncorrectEmailOrPassword value,
          $Res Function(_$IncorrectEmailOrPassword) then) =
      __$$IncorrectEmailOrPasswordCopyWithImpl<$Res>;
}

/// @nodoc
class __$$IncorrectEmailOrPasswordCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$IncorrectEmailOrPasswordCopyWith<$Res> {
  __$$IncorrectEmailOrPasswordCopyWithImpl(_$IncorrectEmailOrPassword _value,
      $Res Function(_$IncorrectEmailOrPassword) _then)
      : super(_value, (v) => _then(v as _$IncorrectEmailOrPassword));

  @override
  _$IncorrectEmailOrPassword get _value =>
      super._value as _$IncorrectEmailOrPassword;
}

/// @nodoc

class _$IncorrectEmailOrPassword implements IncorrectEmailOrPassword {
  const _$IncorrectEmailOrPassword();

  @override
  String toString() {
    return 'AuthFailures.incorrectEmailOrPassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IncorrectEmailOrPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return incorrectEmailOrPassword();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return incorrectEmailOrPassword?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (incorrectEmailOrPassword != null) {
      return incorrectEmailOrPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCurrentUser value) noCurrentUser,
    required TResult Function(NetworkFailure value) networkFailure,
    required TResult Function(IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(CanceledByUser value) canecledByUser,
    required TResult Function(ServerError value) serverError,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return incorrectEmailOrPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
  }) {
    return incorrectEmailOrPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (incorrectEmailOrPassword != null) {
      return incorrectEmailOrPassword(this);
    }
    return orElse();
  }
}

abstract class IncorrectEmailOrPassword implements AuthFailures {
  const factory IncorrectEmailOrPassword() = _$IncorrectEmailOrPassword;
}

/// @nodoc
abstract class _$$EmailAlreadyRegisteredCopyWith<$Res> {
  factory _$$EmailAlreadyRegisteredCopyWith(_$EmailAlreadyRegistered value,
          $Res Function(_$EmailAlreadyRegistered) then) =
      __$$EmailAlreadyRegisteredCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmailAlreadyRegisteredCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$EmailAlreadyRegisteredCopyWith<$Res> {
  __$$EmailAlreadyRegisteredCopyWithImpl(_$EmailAlreadyRegistered _value,
      $Res Function(_$EmailAlreadyRegistered) _then)
      : super(_value, (v) => _then(v as _$EmailAlreadyRegistered));

  @override
  _$EmailAlreadyRegistered get _value =>
      super._value as _$EmailAlreadyRegistered;
}

/// @nodoc

class _$EmailAlreadyRegistered implements EmailAlreadyRegistered {
  const _$EmailAlreadyRegistered();

  @override
  String toString() {
    return 'AuthFailures.emailAlreadyRegistered()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmailAlreadyRegistered);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return emailAlreadyRegistered();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return emailAlreadyRegistered?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (emailAlreadyRegistered != null) {
      return emailAlreadyRegistered();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCurrentUser value) noCurrentUser,
    required TResult Function(NetworkFailure value) networkFailure,
    required TResult Function(IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(CanceledByUser value) canecledByUser,
    required TResult Function(ServerError value) serverError,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return emailAlreadyRegistered(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
  }) {
    return emailAlreadyRegistered?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (emailAlreadyRegistered != null) {
      return emailAlreadyRegistered(this);
    }
    return orElse();
  }
}

abstract class EmailAlreadyRegistered implements AuthFailures {
  const factory EmailAlreadyRegistered() = _$EmailAlreadyRegistered;
}

/// @nodoc
abstract class _$$CanceledByUserCopyWith<$Res> {
  factory _$$CanceledByUserCopyWith(
          _$CanceledByUser value, $Res Function(_$CanceledByUser) then) =
      __$$CanceledByUserCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CanceledByUserCopyWithImpl<$Res>
    extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$CanceledByUserCopyWith<$Res> {
  __$$CanceledByUserCopyWithImpl(
      _$CanceledByUser _value, $Res Function(_$CanceledByUser) _then)
      : super(_value, (v) => _then(v as _$CanceledByUser));

  @override
  _$CanceledByUser get _value => super._value as _$CanceledByUser;
}

/// @nodoc

class _$CanceledByUser implements CanceledByUser {
  const _$CanceledByUser();

  @override
  String toString() {
    return 'AuthFailures.canecledByUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CanceledByUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return canecledByUser();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return canecledByUser?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (canecledByUser != null) {
      return canecledByUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCurrentUser value) noCurrentUser,
    required TResult Function(NetworkFailure value) networkFailure,
    required TResult Function(IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(CanceledByUser value) canecledByUser,
    required TResult Function(ServerError value) serverError,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return canecledByUser(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
  }) {
    return canecledByUser?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (canecledByUser != null) {
      return canecledByUser(this);
    }
    return orElse();
  }
}

abstract class CanceledByUser implements AuthFailures {
  const factory CanceledByUser() = _$CanceledByUser;
}

/// @nodoc
abstract class _$$ServerErrorCopyWith<$Res> {
  factory _$$ServerErrorCopyWith(
          _$ServerError value, $Res Function(_$ServerError) then) =
      __$$ServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ServerErrorCopyWithImpl<$Res> extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$ServerErrorCopyWith<$Res> {
  __$$ServerErrorCopyWithImpl(
      _$ServerError _value, $Res Function(_$ServerError) _then)
      : super(_value, (v) => _then(v as _$ServerError));

  @override
  _$ServerError get _value => super._value as _$ServerError;
}

/// @nodoc

class _$ServerError implements ServerError {
  const _$ServerError();

  @override
  String toString() {
    return 'AuthFailures.serverError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return serverError();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return serverError?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCurrentUser value) noCurrentUser,
    required TResult Function(NetworkFailure value) networkFailure,
    required TResult Function(IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(CanceledByUser value) canecledByUser,
    required TResult Function(ServerError value) serverError,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class ServerError implements AuthFailures {
  const factory ServerError() = _$ServerError;
}

/// @nodoc
abstract class _$$WrongEmailCopyWith<$Res> {
  factory _$$WrongEmailCopyWith(
          _$WrongEmail value, $Res Function(_$WrongEmail) then) =
      __$$WrongEmailCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WrongEmailCopyWithImpl<$Res> extends _$AuthFailuresCopyWithImpl<$Res>
    implements _$$WrongEmailCopyWith<$Res> {
  __$$WrongEmailCopyWithImpl(
      _$WrongEmail _value, $Res Function(_$WrongEmail) _then)
      : super(_value, (v) => _then(v as _$WrongEmail));

  @override
  _$WrongEmail get _value => super._value as _$WrongEmail;
}

/// @nodoc

class _$WrongEmail implements WrongEmail {
  const _$WrongEmail();

  @override
  String toString() {
    return 'AuthFailures.wrongEmail()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WrongEmail);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noCurrentUser,
    required TResult Function() networkFailure,
    required TResult Function() incorrectEmailOrPassword,
    required TResult Function() emailAlreadyRegistered,
    required TResult Function() canecledByUser,
    required TResult Function() serverError,
    required TResult Function() wrongEmail,
  }) {
    return wrongEmail();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
  }) {
    return wrongEmail?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noCurrentUser,
    TResult Function()? networkFailure,
    TResult Function()? incorrectEmailOrPassword,
    TResult Function()? emailAlreadyRegistered,
    TResult Function()? canecledByUser,
    TResult Function()? serverError,
    TResult Function()? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongEmail != null) {
      return wrongEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoCurrentUser value) noCurrentUser,
    required TResult Function(NetworkFailure value) networkFailure,
    required TResult Function(IncorrectEmailOrPassword value)
        incorrectEmailOrPassword,
    required TResult Function(EmailAlreadyRegistered value)
        emailAlreadyRegistered,
    required TResult Function(CanceledByUser value) canecledByUser,
    required TResult Function(ServerError value) serverError,
    required TResult Function(WrongEmail value) wrongEmail,
  }) {
    return wrongEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
  }) {
    return wrongEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoCurrentUser value)? noCurrentUser,
    TResult Function(NetworkFailure value)? networkFailure,
    TResult Function(IncorrectEmailOrPassword value)? incorrectEmailOrPassword,
    TResult Function(EmailAlreadyRegistered value)? emailAlreadyRegistered,
    TResult Function(CanceledByUser value)? canecledByUser,
    TResult Function(ServerError value)? serverError,
    TResult Function(WrongEmail value)? wrongEmail,
    required TResult orElse(),
  }) {
    if (wrongEmail != null) {
      return wrongEmail(this);
    }
    return orElse();
  }
}

abstract class WrongEmail implements AuthFailures {
  const factory WrongEmail() = _$WrongEmail;
}

/// @nodoc
mixin _$CashFailures {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noDataStored,
    required TResult Function() getDataFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoDataStored value) noDataStored,
    required TResult Function(GetDataFailure value) getDataFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoDataStored value)? noDataStored,
    TResult Function(GetDataFailure value)? getDataFailure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoDataStored value)? noDataStored,
    TResult Function(GetDataFailure value)? getDataFailure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CashFailuresCopyWith<$Res> {
  factory $CashFailuresCopyWith(
          CashFailures value, $Res Function(CashFailures) then) =
      _$CashFailuresCopyWithImpl<$Res>;
}

/// @nodoc
class _$CashFailuresCopyWithImpl<$Res> implements $CashFailuresCopyWith<$Res> {
  _$CashFailuresCopyWithImpl(this._value, this._then);

  final CashFailures _value;
  // ignore: unused_field
  final $Res Function(CashFailures) _then;
}

/// @nodoc
abstract class _$$NoDataStoredCopyWith<$Res> {
  factory _$$NoDataStoredCopyWith(
          _$NoDataStored value, $Res Function(_$NoDataStored) then) =
      __$$NoDataStoredCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoDataStoredCopyWithImpl<$Res>
    extends _$CashFailuresCopyWithImpl<$Res>
    implements _$$NoDataStoredCopyWith<$Res> {
  __$$NoDataStoredCopyWithImpl(
      _$NoDataStored _value, $Res Function(_$NoDataStored) _then)
      : super(_value, (v) => _then(v as _$NoDataStored));

  @override
  _$NoDataStored get _value => super._value as _$NoDataStored;
}

/// @nodoc

class _$NoDataStored implements NoDataStored {
  const _$NoDataStored();

  @override
  String toString() {
    return 'CashFailures.noDataStored()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoDataStored);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noDataStored,
    required TResult Function() getDataFailure,
  }) {
    return noDataStored();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
  }) {
    return noDataStored?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
    required TResult orElse(),
  }) {
    if (noDataStored != null) {
      return noDataStored();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoDataStored value) noDataStored,
    required TResult Function(GetDataFailure value) getDataFailure,
  }) {
    return noDataStored(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoDataStored value)? noDataStored,
    TResult Function(GetDataFailure value)? getDataFailure,
  }) {
    return noDataStored?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoDataStored value)? noDataStored,
    TResult Function(GetDataFailure value)? getDataFailure,
    required TResult orElse(),
  }) {
    if (noDataStored != null) {
      return noDataStored(this);
    }
    return orElse();
  }
}

abstract class NoDataStored implements CashFailures {
  const factory NoDataStored() = _$NoDataStored;
}

/// @nodoc
abstract class _$$GetDataFailureCopyWith<$Res> {
  factory _$$GetDataFailureCopyWith(
          _$GetDataFailure value, $Res Function(_$GetDataFailure) then) =
      __$$GetDataFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetDataFailureCopyWithImpl<$Res>
    extends _$CashFailuresCopyWithImpl<$Res>
    implements _$$GetDataFailureCopyWith<$Res> {
  __$$GetDataFailureCopyWithImpl(
      _$GetDataFailure _value, $Res Function(_$GetDataFailure) _then)
      : super(_value, (v) => _then(v as _$GetDataFailure));

  @override
  _$GetDataFailure get _value => super._value as _$GetDataFailure;
}

/// @nodoc

class _$GetDataFailure implements GetDataFailure {
  const _$GetDataFailure();

  @override
  String toString() {
    return 'CashFailures.getDataFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetDataFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noDataStored,
    required TResult Function() getDataFailure,
  }) {
    return getDataFailure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
  }) {
    return getDataFailure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noDataStored,
    TResult Function()? getDataFailure,
    required TResult orElse(),
  }) {
    if (getDataFailure != null) {
      return getDataFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoDataStored value) noDataStored,
    required TResult Function(GetDataFailure value) getDataFailure,
  }) {
    return getDataFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(NoDataStored value)? noDataStored,
    TResult Function(GetDataFailure value)? getDataFailure,
  }) {
    return getDataFailure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoDataStored value)? noDataStored,
    TResult Function(GetDataFailure value)? getDataFailure,
    required TResult orElse(),
  }) {
    if (getDataFailure != null) {
      return getDataFailure(this);
    }
    return orElse();
  }
}

abstract class GetDataFailure implements CashFailures {
  const factory GetDataFailure() = _$GetDataFailure;
}
